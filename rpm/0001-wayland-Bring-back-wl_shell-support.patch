From dbc4226ad8666479f39ef0bccf0a3042e48712e8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Matti=20Lehtim=C3=A4ki?= <matti.lehtimaki@jolla.com>
Date: Wed, 1 Dec 2021 15:37:41 +0200
Subject: [PATCH] wayland: Bring back wl_shell support.

---
 include/SDL_syswm.h                   |  2 +-
 src/video/wayland/SDL_waylanddyn.h    |  2 +
 src/video/wayland/SDL_waylandevents.c |  8 +++
 src/video/wayland/SDL_waylandsym.h    |  2 +
 src/video/wayland/SDL_waylandvideo.c  |  5 ++
 src/video/wayland/SDL_waylandvideo.h  |  1 +
 src/video/wayland/SDL_waylandwindow.c | 92 +++++++++++++++++++++++++++
 src/video/wayland/SDL_waylandwindow.h |  1 +
 8 files changed, 112 insertions(+), 1 deletion(-)

diff --git a/include/SDL_syswm.h b/include/SDL_syswm.h
index d25efc14b..1f60a2fc7 100644
--- a/include/SDL_syswm.h
+++ b/include/SDL_syswm.h
@@ -290,7 +290,7 @@ struct SDL_SysWMinfo
         {
             struct wl_display *display;             /**< Wayland display */
             struct wl_surface *surface;             /**< Wayland surface */
-            void *shell_surface;                    /**< DEPRECATED Wayland shell_surface (window manager handle) */
+            struct wl_shell_surface *shell_surface; /**< DEPRECATED Wayland shell_surface (window manager handle) */
             struct wl_egl_window *egl_window;       /**< Wayland EGL window (native window) */
             struct xdg_surface *xdg_surface;        /**< Wayland xdg surface (window manager handle) */
             struct xdg_toplevel *xdg_toplevel;      /**< Wayland xdg toplevel role */
diff --git a/src/video/wayland/SDL_waylanddyn.h b/src/video/wayland/SDL_waylanddyn.h
index 13b0884d0..229ea8b50 100644
--- a/src/video/wayland/SDL_waylanddyn.h
+++ b/src/video/wayland/SDL_waylanddyn.h
@@ -101,11 +101,13 @@ void SDL_WAYLAND_UnloadSymbols(void);
 #define wl_shm_pool_interface (*WAYLAND_wl_shm_pool_interface)
 #define wl_buffer_interface (*WAYLAND_wl_buffer_interface)
 #define wl_registry_interface (*WAYLAND_wl_registry_interface)
+#define wl_shell_surface_interface (*WAYLAND_wl_shell_surface_interface)
 #define wl_region_interface (*WAYLAND_wl_region_interface)
 #define wl_pointer_interface (*WAYLAND_wl_pointer_interface)
 #define wl_keyboard_interface (*WAYLAND_wl_keyboard_interface)
 #define wl_compositor_interface (*WAYLAND_wl_compositor_interface)
 #define wl_output_interface (*WAYLAND_wl_output_interface)
+#define wl_shell_interface (*WAYLAND_wl_shell_interface)
 #define wl_shm_interface (*WAYLAND_wl_shm_interface)
 #define wl_data_device_interface (*WAYLAND_wl_data_device_interface)
 #define wl_data_offer_interface (*WAYLAND_wl_data_offer_interface)
diff --git a/src/video/wayland/SDL_waylandevents.c b/src/video/wayland/SDL_waylandevents.c
index 1f48a0612..bbf028a92 100644
--- a/src/video/wayland/SDL_waylandevents.c
+++ b/src/video/wayland/SDL_waylandevents.c
@@ -452,6 +452,10 @@ ProcessHitTest(struct SDL_WaylandInput *input, uint32_t serial)
                                           input->seat,
                                           serial);
                     }
+                } else {
+                    if (window_data->shell_surface.wl) {
+                        wl_shell_surface_move(window_data->shell_surface.wl, input->seat, serial);
+                    }
                 }
                 return SDL_TRUE;
 
@@ -477,6 +481,10 @@ ProcessHitTest(struct SDL_WaylandInput *input, uint32_t serial)
                                             serial,
                                             directions[rc - SDL_HITTEST_RESIZE_TOPLEFT]);
                     }
+                } else {
+                    if (window_data->shell_surface.wl) {
+                        wl_shell_surface_resize(window_data->shell_surface.wl, input->seat, serial, directions[rc - SDL_HITTEST_RESIZE_TOPLEFT]);
+                    }
                 }
                 return SDL_TRUE;
 
diff --git a/src/video/wayland/SDL_waylandsym.h b/src/video/wayland/SDL_waylandsym.h
index d6e6a761d..7165f2c53 100644
--- a/src/video/wayland/SDL_waylandsym.h
+++ b/src/video/wayland/SDL_waylandsym.h
@@ -89,11 +89,13 @@ SDL_WAYLAND_INTERFACE(wl_surface_interface)
 SDL_WAYLAND_INTERFACE(wl_shm_pool_interface)
 SDL_WAYLAND_INTERFACE(wl_buffer_interface)
 SDL_WAYLAND_INTERFACE(wl_registry_interface)
+SDL_WAYLAND_INTERFACE(wl_shell_surface_interface)
 SDL_WAYLAND_INTERFACE(wl_region_interface)
 SDL_WAYLAND_INTERFACE(wl_pointer_interface)
 SDL_WAYLAND_INTERFACE(wl_keyboard_interface)
 SDL_WAYLAND_INTERFACE(wl_compositor_interface)
 SDL_WAYLAND_INTERFACE(wl_output_interface)
+SDL_WAYLAND_INTERFACE(wl_shell_interface)
 SDL_WAYLAND_INTERFACE(wl_shm_interface)
 SDL_WAYLAND_INTERFACE(wl_data_device_interface)
 SDL_WAYLAND_INTERFACE(wl_data_source_interface)
diff --git a/src/video/wayland/SDL_waylandvideo.c b/src/video/wayland/SDL_waylandvideo.c
index 6d6d951d4..1bca37c0d 100644
--- a/src/video/wayland/SDL_waylandvideo.c
+++ b/src/video/wayland/SDL_waylandvideo.c
@@ -600,6 +600,8 @@ display_handle_global(void *data, struct wl_registry *registry, uint32_t id,
     } else if (SDL_strcmp(interface, "xdg_wm_base") == 0) {
         d->shell.xdg = wl_registry_bind(d->registry, id, &xdg_wm_base_interface, 1);
         xdg_wm_base_add_listener(d->shell.xdg, &shell_listener_xdg, NULL);
+    } else if (SDL_strcmp(interface, "wl_shell") == 0) {
+        d->shell.wl = wl_registry_bind(d->registry, id, &wl_shell_interface, 1);
     } else if (SDL_strcmp(interface, "wl_shm") == 0) {
         d->shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
     } else if (SDL_strcmp(interface, "zwp_relative_pointer_manager_v1") == 0) {
@@ -783,6 +785,9 @@ Wayland_VideoQuit(_THIS)
     if (data->shm)
         wl_shm_destroy(data->shm);
 
+    if (data->shell.wl)
+        wl_shell_destroy(data->shell.wl);
+
     if (data->shell.xdg)
         xdg_wm_base_destroy(data->shell.xdg);
 
diff --git a/src/video/wayland/SDL_waylandvideo.h b/src/video/wayland/SDL_waylandvideo.h
index e82c7ec0b..ac9328726 100644
--- a/src/video/wayland/SDL_waylandvideo.h
+++ b/src/video/wayland/SDL_waylandvideo.h
@@ -58,6 +58,7 @@ typedef struct {
     struct wl_pointer *pointer;
     struct {
         struct xdg_wm_base *xdg;
+        struct wl_shell *wl;
 #ifdef HAVE_LIBDECOR_H
         struct libdecor *libdecor;
 #endif
diff --git a/src/video/wayland/SDL_waylandwindow.c b/src/video/wayland/SDL_waylandwindow.c
index 581f4b002..4c092d0ba 100644
--- a/src/video/wayland/SDL_waylandwindow.c
+++ b/src/video/wayland/SDL_waylandwindow.c
@@ -134,6 +134,17 @@ SetFullscreen(SDL_Window *window, struct wl_output *output)
         } else {
             xdg_toplevel_unset_fullscreen(wind->shell_surface.xdg.roleobj.toplevel);
         }
+    } else {
+        if (wind->shell_surface.wl == NULL) {
+            return; /* Can't do anything yet, wait for ShowWindow */
+        }
+        if (output) {
+            wl_shell_surface_set_fullscreen(wind->shell_surface.wl,
+                                            WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT,
+                                            0, output);
+        } else {
+            wl_shell_surface_set_toplevel(wind->shell_surface.wl);
+        }
     }
 }
 
@@ -158,6 +169,62 @@ static const struct wl_callback_listener surface_frame_listener = {
 
 static void Wayland_HandleResize(SDL_Window *window, int width, int height, float scale);
 
+/* On modern desktops, we probably will use the xdg-shell protocol instead
+   of wl_shell, but wl_shell might be useful on older Wayland installs that
+   don't have the newer protocol, or embedded things that don't have a full
+   window manager. */
+
+static void
+handle_ping_wl_shell_surface(void *data, struct wl_shell_surface *shell_surface,
+            uint32_t serial)
+{
+    wl_shell_surface_pong(shell_surface, serial);
+}
+
+static void
+handle_configure_wl_shell_surface(void *data, struct wl_shell_surface *shell_surface,
+                 uint32_t edges, int32_t width, int32_t height)
+{
+    SDL_WindowData *wind = (SDL_WindowData *)data;
+    SDL_Window *window = wind->sdlwindow;
+
+    /* wl_shell_surface spec states that this is a suggestion.
+       Ignore if less than or greater than max/min size. */
+
+    if (width == 0 || height == 0) {
+        return;
+    }
+
+    if (!(window->flags & SDL_WINDOW_FULLSCREEN)) {
+        if ((window->flags & SDL_WINDOW_RESIZABLE)) {
+            if (window->max_w > 0) {
+                width = SDL_min(width, window->max_w);
+            }
+            width = SDL_max(width, window->min_w);
+
+            if (window->max_h > 0) {
+                height = SDL_min(height, window->max_h);
+            }
+            height = SDL_max(height, window->min_h);
+        } else {
+            return;
+        }
+    }
+
+    Wayland_HandleResize(window, width, height, wind->scale_factor);
+}
+
+static void
+handle_popup_done_wl_shell_surface(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static const struct wl_shell_surface_listener shell_surface_listener_wl = {
+    handle_ping_wl_shell_surface,
+    handle_configure_wl_shell_surface,
+    handle_popup_done_wl_shell_surface
+};
+
 static void
 handle_configure_xdg_shell_surface(void *data, struct xdg_surface *xdg, uint32_t serial)
 {
@@ -743,6 +810,11 @@ void Wayland_ShowWindow(_THIS, SDL_Window *window)
         data->shell_surface.xdg.roleobj.toplevel = xdg_surface_get_toplevel(data->shell_surface.xdg.surface);
         xdg_toplevel_set_app_id(data->shell_surface.xdg.roleobj.toplevel, c->classname);
         xdg_toplevel_add_listener(data->shell_surface.xdg.roleobj.toplevel, &toplevel_listener_xdg, data);
+    } else {
+        data->shell_surface.wl = wl_shell_get_shell_surface(c->shell.wl, data->surface);
+        wl_shell_surface_set_class(data->shell_surface.wl, c->classname);
+        wl_shell_surface_set_user_data(data->shell_surface.wl, data);
+        wl_shell_surface_add_listener(data->shell_surface.wl, &shell_surface_listener_wl, data);
     }
 
     /* Restore state that was set prior to this call */
@@ -844,6 +916,11 @@ void Wayland_HideWindow(_THIS, SDL_Window *window)
             xdg_surface_destroy(wind->shell_surface.xdg.surface);
             wind->shell_surface.xdg.surface = NULL;
         }
+    } else {
+        if (wind->shell_surface.wl) {
+            wl_shell_surface_destroy(wind->shell_surface.wl);
+            wind->shell_surface.wl = NULL;
+        }
     }
 }
 
@@ -1068,6 +1145,11 @@ Wayland_RestoreWindow(_THIS, SDL_Window * window)
             return; /* Can't do anything yet, wait for ShowWindow */
         }
         xdg_toplevel_unset_maximized(wind->shell_surface.xdg.roleobj.toplevel);
+    } else {
+        if (wind->shell_surface.wl == NULL) {
+            return; /* Can't do anything yet, wait for ShowWindow */
+        }
+        wl_shell_surface_set_toplevel(wind->shell_surface.wl);
     }
 
     WAYLAND_wl_display_flush( viddata->display );
@@ -1142,6 +1224,11 @@ Wayland_MaximizeWindow(_THIS, SDL_Window * window)
             return; /* Can't do anything yet, wait for ShowWindow */
         }
         xdg_toplevel_set_maximized(wind->shell_surface.xdg.roleobj.toplevel);
+    } else {
+        if (wind->shell_surface.wl == NULL) {
+            return; /* Can't do anything yet, wait for ShowWindow */
+        }
+        wl_shell_surface_set_maximized(wind->shell_surface.wl, NULL);
     }
 
     WAYLAND_wl_display_flush(viddata->display);
@@ -1450,6 +1537,11 @@ void Wayland_SetWindowTitle(_THIS, SDL_Window * window)
                 return; /* Can't do anything yet, wait for ShowWindow */
             }
             xdg_toplevel_set_title(wind->shell_surface.xdg.roleobj.toplevel, window->title);
+        } else {
+            if (wind->shell_surface.wl == NULL) {
+                return; /* Can'd do anything yet, wait for ShowWindow */
+            }
+            wl_shell_surface_set_title(wind->shell_surface.wl, window->title);
         }
     }
 
diff --git a/src/video/wayland/SDL_waylandwindow.h b/src/video/wayland/SDL_waylandwindow.h
index f6656997b..a275ae63e 100644
--- a/src/video/wayland/SDL_waylandwindow.h
+++ b/src/video/wayland/SDL_waylandwindow.h
@@ -60,6 +60,7 @@ typedef struct {
         SDL_libdecor_surface libdecor;
 #endif
         SDL_xdg_shell_surface xdg;
+        struct wl_shell_surface *wl;
     } shell_surface;
     struct wl_egl_window *egl_window;
     struct SDL_WaylandInput *keyboard_device;
-- 
2.25.1

