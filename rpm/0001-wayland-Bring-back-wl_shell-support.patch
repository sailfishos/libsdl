From 76696e0e3e6081d476120138910a66ea6c66cc10 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Matti=20Lehtim=C3=A4ki?= <matti.lehtimaki@jolla.com>
Date: Wed, 4 Aug 2021 02:29:34 +0300
Subject: [PATCH] wayland: Bring back wl_shell support.

---
 include/SDL_syswm.h                   |  2 +-
 src/video/wayland/SDL_waylanddyn.h    |  2 +
 src/video/wayland/SDL_waylandevents.c |  8 +++
 src/video/wayland/SDL_waylandsym.h    |  2 +
 src/video/wayland/SDL_waylandvideo.c  |  5 ++
 src/video/wayland/SDL_waylandvideo.h  |  1 +
 src/video/wayland/SDL_waylandwindow.c | 92 +++++++++++++++++++++++++++
 src/video/wayland/SDL_waylandwindow.h |  1 +
 8 files changed, 112 insertions(+), 1 deletion(-)

diff --git a/include/SDL_syswm.h b/include/SDL_syswm.h
index 046a096ee..0092d0065 100644
--- a/include/SDL_syswm.h
+++ b/include/SDL_syswm.h
@@ -289,7 +289,7 @@ struct SDL_SysWMinfo
         {
             struct wl_display *display;             /**< Wayland display */
             struct wl_surface *surface;             /**< Wayland surface */
-            void *shell_surface;                    /**< DEPRECATED Wayland shell_surface (window manager handle) */
+            struct wl_shell_surface *shell_surface; /**< DEPRECATED Wayland shell_surface (window manager handle) */
             struct wl_egl_window *egl_window;       /**< Wayland EGL window (native window) */
             struct xdg_surface *xdg_surface;        /**< Wayland xdg surface (window manager handle) */
         } wl;
diff --git a/src/video/wayland/SDL_waylanddyn.h b/src/video/wayland/SDL_waylanddyn.h
index 6cd527316..868b14503 100644
--- a/src/video/wayland/SDL_waylanddyn.h
+++ b/src/video/wayland/SDL_waylanddyn.h
@@ -101,11 +101,13 @@ void SDL_WAYLAND_UnloadSymbols(void);
 #define wl_shm_pool_interface (*WAYLAND_wl_shm_pool_interface)
 #define wl_buffer_interface (*WAYLAND_wl_buffer_interface)
 #define wl_registry_interface (*WAYLAND_wl_registry_interface)
+#define wl_shell_surface_interface (*WAYLAND_wl_shell_surface_interface)
 #define wl_region_interface (*WAYLAND_wl_region_interface)
 #define wl_pointer_interface (*WAYLAND_wl_pointer_interface)
 #define wl_keyboard_interface (*WAYLAND_wl_keyboard_interface)
 #define wl_compositor_interface (*WAYLAND_wl_compositor_interface)
 #define wl_output_interface (*WAYLAND_wl_output_interface)
+#define wl_shell_interface (*WAYLAND_wl_shell_interface)
 #define wl_shm_interface (*WAYLAND_wl_shm_interface)
 #define wl_data_device_interface (*WAYLAND_wl_data_device_interface)
 #define wl_data_offer_interface (*WAYLAND_wl_data_offer_interface)
diff --git a/src/video/wayland/SDL_waylandevents.c b/src/video/wayland/SDL_waylandevents.c
index 171a7a009..f31bd1314 100644
--- a/src/video/wayland/SDL_waylandevents.c
+++ b/src/video/wayland/SDL_waylandevents.c
@@ -355,6 +355,10 @@ ProcessHitTest(struct SDL_WaylandInput *input, uint32_t serial)
                                           input->seat,
                                           serial);
                     }
+                } else {
+                    if (window_data->shell_surface.wl) {
+                        wl_shell_surface_move(window_data->shell_surface.wl, input->seat, serial);
+                    }
                 }
                 return SDL_TRUE;
 
@@ -380,6 +384,10 @@ ProcessHitTest(struct SDL_WaylandInput *input, uint32_t serial)
                                             serial,
                                             directions[rc - SDL_HITTEST_RESIZE_TOPLEFT]);
                     }
+                } else {
+                    if (window_data->shell_surface.wl) {
+                        wl_shell_surface_resize(window_data->shell_surface.wl, input->seat, serial, directions[rc - SDL_HITTEST_RESIZE_TOPLEFT]);
+                    }
                 }
                 return SDL_TRUE;
 
diff --git a/src/video/wayland/SDL_waylandsym.h b/src/video/wayland/SDL_waylandsym.h
index 10602740b..85cc5eb03 100644
--- a/src/video/wayland/SDL_waylandsym.h
+++ b/src/video/wayland/SDL_waylandsym.h
@@ -82,11 +82,13 @@ SDL_WAYLAND_INTERFACE(wl_surface_interface)
 SDL_WAYLAND_INTERFACE(wl_shm_pool_interface)
 SDL_WAYLAND_INTERFACE(wl_buffer_interface)
 SDL_WAYLAND_INTERFACE(wl_registry_interface)
+SDL_WAYLAND_INTERFACE(wl_shell_surface_interface)
 SDL_WAYLAND_INTERFACE(wl_region_interface)
 SDL_WAYLAND_INTERFACE(wl_pointer_interface)
 SDL_WAYLAND_INTERFACE(wl_keyboard_interface)
 SDL_WAYLAND_INTERFACE(wl_compositor_interface)
 SDL_WAYLAND_INTERFACE(wl_output_interface)
+SDL_WAYLAND_INTERFACE(wl_shell_interface)
 SDL_WAYLAND_INTERFACE(wl_shm_interface)
 SDL_WAYLAND_INTERFACE(wl_data_device_interface)
 SDL_WAYLAND_INTERFACE(wl_data_source_interface)
diff --git a/src/video/wayland/SDL_waylandvideo.c b/src/video/wayland/SDL_waylandvideo.c
index 01e553063..5eddee930 100644
--- a/src/video/wayland/SDL_waylandvideo.c
+++ b/src/video/wayland/SDL_waylandvideo.c
@@ -492,6 +492,8 @@ display_handle_global(void *data, struct wl_registry *registry, uint32_t id,
     } else if (SDL_strcmp(interface, "xdg_wm_base") == 0) {
         d->shell.xdg = wl_registry_bind(d->registry, id, &xdg_wm_base_interface, 1);
         xdg_wm_base_add_listener(d->shell.xdg, &shell_listener_xdg, NULL);
+    } else if (SDL_strcmp(interface, "wl_shell") == 0) {
+        d->shell.wl = wl_registry_bind(d->registry, id, &wl_shell_interface, 1);
     } else if (SDL_strcmp(interface, "wl_shm") == 0) {
         d->shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
         d->cursor_theme = WAYLAND_wl_cursor_theme_load(NULL, 32, d->shm);
@@ -673,6 +675,9 @@ Wayland_VideoQuit(_THIS)
     if (data->cursor_theme)
         WAYLAND_wl_cursor_theme_destroy(data->cursor_theme);
 
+    if (data->shell.wl)
+        wl_shell_destroy(data->shell.wl);
+
     if (data->shell.xdg)
         xdg_wm_base_destroy(data->shell.xdg);
 
diff --git a/src/video/wayland/SDL_waylandvideo.h b/src/video/wayland/SDL_waylandvideo.h
index 60336b6cc..a7b90e07e 100644
--- a/src/video/wayland/SDL_waylandvideo.h
+++ b/src/video/wayland/SDL_waylandvideo.h
@@ -51,6 +51,7 @@ typedef struct {
     struct wl_pointer *pointer;
     struct {
         struct xdg_wm_base *xdg;
+        struct wl_shell *wl;
 #ifdef HAVE_LIBDECOR_H
         struct libdecor *libdecor;
 #endif
diff --git a/src/video/wayland/SDL_waylandwindow.c b/src/video/wayland/SDL_waylandwindow.c
index 025dd30ee..384605526 100644
--- a/src/video/wayland/SDL_waylandwindow.c
+++ b/src/video/wayland/SDL_waylandwindow.c
@@ -134,6 +134,17 @@ SetFullscreen(SDL_Window *window, struct wl_output *output)
         } else {
             xdg_toplevel_unset_fullscreen(wind->shell_surface.xdg.roleobj.toplevel);
         }
+    } else {
+        if (wind->shell_surface.wl == NULL) {
+            return; /* Can't do anything yet, wait for ShowWindow */
+        }
+        if (output) {
+            wl_shell_surface_set_fullscreen(wind->shell_surface.wl,
+                                            WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT,
+                                            0, output);
+        } else {
+            wl_shell_surface_set_toplevel(wind->shell_surface.wl);
+        }
     }
 }
 
@@ -158,6 +169,62 @@ static const struct wl_callback_listener surface_frame_listener = {
 
 static void Wayland_HandleResize(SDL_Window *window, int width, int height, float scale);
 
+/* On modern desktops, we probably will use the xdg-shell protocol instead
+   of wl_shell, but wl_shell might be useful on older Wayland installs that
+   don't have the newer protocol, or embedded things that don't have a full
+   window manager. */
+
+static void
+handle_ping_wl_shell_surface(void *data, struct wl_shell_surface *shell_surface,
+            uint32_t serial)
+{
+    wl_shell_surface_pong(shell_surface, serial);
+}
+
+static void
+handle_configure_wl_shell_surface(void *data, struct wl_shell_surface *shell_surface,
+                 uint32_t edges, int32_t width, int32_t height)
+{
+    SDL_WindowData *wind = (SDL_WindowData *)data;
+    SDL_Window *window = wind->sdlwindow;
+
+    /* wl_shell_surface spec states that this is a suggestion.
+       Ignore if less than or greater than max/min size. */
+
+    if (width == 0 || height == 0) {
+        return;
+    }
+
+    if (!(window->flags & SDL_WINDOW_FULLSCREEN)) {
+        if ((window->flags & SDL_WINDOW_RESIZABLE)) {
+            if (window->max_w > 0) {
+                width = SDL_min(width, window->max_w);
+            }
+            width = SDL_max(width, window->min_w);
+
+            if (window->max_h > 0) {
+                height = SDL_min(height, window->max_h);
+            }
+            height = SDL_max(height, window->min_h);
+        } else {
+            return;
+        }
+    }
+
+    Wayland_HandleResize(window, width, height, wind->scale_factor);
+}
+
+static void
+handle_popup_done_wl_shell_surface(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static const struct wl_shell_surface_listener shell_surface_listener_wl = {
+    handle_ping_wl_shell_surface,
+    handle_configure_wl_shell_surface,
+    handle_popup_done_wl_shell_surface
+};
+
 static void
 handle_configure_xdg_shell_surface(void *data, struct xdg_surface *xdg, uint32_t serial)
 {
@@ -728,6 +795,11 @@ void Wayland_ShowWindow(_THIS, SDL_Window *window)
         data->shell_surface.xdg.roleobj.toplevel = xdg_surface_get_toplevel(data->shell_surface.xdg.surface);
         xdg_toplevel_set_app_id(data->shell_surface.xdg.roleobj.toplevel, c->classname);
         xdg_toplevel_add_listener(data->shell_surface.xdg.roleobj.toplevel, &toplevel_listener_xdg, data);
+    } else {
+        data->shell_surface.wl = wl_shell_get_shell_surface(c->shell.wl, data->surface);
+        wl_shell_surface_set_class(data->shell_surface.wl, c->classname);
+        wl_shell_surface_set_user_data(data->shell_surface.wl, data);
+        wl_shell_surface_add_listener(data->shell_surface.wl, &shell_surface_listener_wl, data);
     }
 
     /* Restore state that was set prior to this call */
@@ -829,6 +901,11 @@ void Wayland_HideWindow(_THIS, SDL_Window *window)
             xdg_surface_destroy(wind->shell_surface.xdg.surface);
             wind->shell_surface.xdg.surface = NULL;
         }
+    } else {
+        if (wind->shell_surface.wl) {
+            wl_shell_surface_destroy(wind->shell_surface.wl);
+            wind->shell_surface.wl = NULL;
+        }
     }
 }
 
@@ -1035,6 +1112,11 @@ Wayland_RestoreWindow(_THIS, SDL_Window * window)
             return; /* Can't do anything yet, wait for ShowWindow */
         }
         xdg_toplevel_unset_maximized(wind->shell_surface.xdg.roleobj.toplevel);
+    } else {
+        if (wind->shell_surface.wl == NULL) {
+            return; /* Can't do anything yet, wait for ShowWindow */
+        }
+        wl_shell_surface_set_toplevel(wind->shell_surface.wl);
     }
 
     WAYLAND_wl_display_flush( viddata->display );
@@ -1109,6 +1191,11 @@ Wayland_MaximizeWindow(_THIS, SDL_Window * window)
             return; /* Can't do anything yet, wait for ShowWindow */
         }
         xdg_toplevel_set_maximized(wind->shell_surface.xdg.roleobj.toplevel);
+    } else {
+        if (wind->shell_surface.wl == NULL) {
+            return; /* Can't do anything yet, wait for ShowWindow */
+        }
+        wl_shell_surface_set_maximized(wind->shell_surface.wl, NULL);
     }
 
     WAYLAND_wl_display_flush(viddata->display);
@@ -1394,6 +1481,11 @@ void Wayland_SetWindowTitle(_THIS, SDL_Window * window)
                 return; /* Can't do anything yet, wait for ShowWindow */
             }
             xdg_toplevel_set_title(wind->shell_surface.xdg.roleobj.toplevel, window->title);
+        } else {
+            if (wind->shell_surface.wl == NULL) {
+                return; /* Can'd do anything yet, wait for ShowWindow */
+            }
+            wl_shell_surface_set_title(wind->shell_surface.wl, window->title);
         }
     }
 
diff --git a/src/video/wayland/SDL_waylandwindow.h b/src/video/wayland/SDL_waylandwindow.h
index 852a8dc0a..18de69c69 100644
--- a/src/video/wayland/SDL_waylandwindow.h
+++ b/src/video/wayland/SDL_waylandwindow.h
@@ -58,6 +58,7 @@ typedef struct {
         SDL_libdecor_surface libdecor;
 #endif
         SDL_xdg_shell_surface xdg;
+        struct wl_shell_surface *wl;
     } shell_surface;
     struct wl_egl_window *egl_window;
     struct SDL_WaylandInput *keyboard_device;
-- 
2.25.1

